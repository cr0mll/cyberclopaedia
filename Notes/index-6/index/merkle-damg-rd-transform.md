# Merkle-Damgård Transform

## Introduction

In practice, it is easier to construct hashing algorithms which operate on relatively small, fixed input lengths, whilst still keeping the output length even smaller ($$l_{\text{out}}$$ is still less than $$l_{\text{in}}$$). But hash functions are usually used on much larger inputs - for example, creating checksums for integrity verification of files. The Merkle-Damgård transform allows us to turn such a hash function, which operates on small fixed input lengths, into a hash function which operates on inputs of arbitrary lengths.

## The Merkle-Damgård Construction

In particular, given a compression function $$H'(\textit{input}: \textbf{str}[\textbf{const } l_{\text{in}}]) \to \textbf{str}[\textbf{const }l]$$ which works with inputs of a "small", fixed input length $$l_{\text{in}}$$ and has outputs with length $$l$$, the Merkle-Damgård transform allows us to use $$H'$$ to a construct a hash function $$H(\textit{input}: \textbf{str}[l_{\text{m}}]) \to \textbf{str}[\textbf{const }l]$$ which takes messages of arbitrary length, denoted by $$l_{\text{m}}$$, and produces digests of the same output length $$l$$ as $$H'$$.

The construction is similar to a block cipher in the sense that the message $$m$$ is chopped up into blocks. In contrast to block ciphers, however, this is done rather differently. Each block has length $$l_{\text{in}}$$ (since each block will be input into $$H'$$), but it is not comprised entirely of message bits. Instead, each block contains $$l_{\text{mb}}$$ message bits and the other $$l_t$$ bits ($$l_t = l_{\text{in}} - l_{\text{mb}}$$) represent the so-called _chaining variable_ for the current block.

This means that the message $$m$$ needs to be chopped up into $$w$$ message fragments $$\mu_1, \mu_2, ..., \mu_q$$, all of length $$l_{\text{mb}}$$. If the message length $$l_m$$ is not a multiple of $$l_{\text{mb}}$$, then the message is padded by appending a 1 to it and then appending 0s until the message length is short of a multiple of the fragment length $$l_{\text{mb}}$$ by exactly the number of bits $$l_e$$ needed to encode the message length $$l_m$$. The total length of the padding (including the 1, the 0s and the encoding of the message length) is denoted by $$l_{\text{pad}} = 1 + \textit{count}(0) + l_e$$.

<figure><img src="../../.gitbook/assets/Merkle-Damgard Padding.svg" alt=""><figcaption></figcaption></figure>

When the message length $$l_m$$ _is_ a multiple of the fragment length $$l_{\text{mb}}$$, padding _still_ needs to be added. In a particular, an additional padding block is appended to the message, following the exact same procedure as before. The padding block begins with a $1$ and is followed by $$0$$s - the last $$l_e$$ bits of the padding block again encode the message length $$l_m$$.

{% hint style="info" %}
The number of bits reserved for encoding the message length $$l_{mb}$$ is fixed for a given Merkle-Damgård construction. Usually $$l_e$$ is 64 bits, resulting in a maximum message length of $$2^{64} - 1$$, which is quite a reasonable limit.
{% endhint %}

After padding, the actual hash algorithm begins by appending an initialisation vector (IV) of length $$l$$ to the first message fragment $$\mu_1$$. The IV is always a constant which is pre-defined in the specification of the Merkle-Damgård construction.

<details>

<summary><strong>Example: The IV of SHA256</strong></summary>

The SHA256 hash function uses the following 256-bit IV (the value is in hex):

$$IV := \texttt{0x6A09E667BB67AE853C6EF372A54FF53A510E527F9B05688C1F83D9AB5BE0CD19}$$

</details>

This initialisation vector serves as the initial chaining variable $$t_1$$. The concatenation $$\mu_1 || IV$$ of the first message block $$\mu_1$$ with the IV is passed to the compression function $$H'$$, whose output becomes the next chaining variable. In general, the $$i$$-th iteration takes the $$i$$-th message block $$\mu_i$$ and appends to it the chaining variable $$t_i$$. The chaining variable $$t_i$$ for the current stage is simply the output of $$H'$$ from the previous iteration. The final output, i.e. the hash generated by the Merkle-Damgård function $$H$$, is the final chaining variable.

<figure><img src="../../.gitbook/assets/Merkle-Damgård Construction.svg" alt=""><figcaption></figcaption></figure>

#### Security of Merkle-Damgård Constructions

The reason why the Merkle-Damgård transform is used ubiquitously is the fact that it preserves collision resistance.

{% hint style="success" %}
<mark style="color:green;">**Theorem: Merkle-Damgård Collision Resistance**</mark>

If the compression function $$H'$$ is collision resistant, then so is the Merkle-Damgård function $$H$$.
{% endhint %}

<details>

<summary><mark style="color:green;"><strong>Proof: Merkle-Damgård Collision Resistance</strong></mark></summary>

Suppose, towards contradiction that there is an efficient collision finder $$\mathcal{A}$$ which can find a collision in $$H$$ with non-negligible probability. Let $$x$$ and $$x'$$ be two inputs of lengths $$L$$ and $$L'$$, respectively, such that $$H(x) = H(x')$$. Let $$x_1, x_2, ..., x_q$$ be the $$q$$ blocks which $$x$$ is divided into, and, let $$x_1', x_2', ..., x_{q'}'$$ be the $$q'$$ blocks which $$x'$$ is divided into. Similarly, let $$t_1, t_2, ..., t_q, t_{q+1}$$ and $$t_1', t_2', ..., t_{q'}', t_{q'+1}'$$ be the chaining variables used at each iteration of the hashing of $$x$$ and $$x'$$, respectively (remember that the chaining variables $$t_{q+1}$$ and $$t_{q'+1}'$$ are also the output of $$H$$).

**Case 1:** If the two inputs have different lengths, i.e. $$L \ne L'$$, then the hash $$H(x)$$ is $$t_{q+1} \coloneqq H'(x_q||t_{q})$$ and the hash $$H(x')$$ is $$t_{q'+1}' \coloneqq H'(x_q'||t_{q'}')$$. However, $$H(x) = H(x')$$ means that $$H'(x_q||t_{q}) = H'(x_q'||t_{q'}')$$ which is a contradiction because $$L\ne L'$$ and so $$x_q \ne x_{q'}'$$ (remember that the length is appended to the message when padding) - we have found two different inputs which cause a collision in the collision resistant $$H'$$.

**Case 2:** If the two inputs have the same length, i.e. $$L = L'$$, then they are also divided into the same number of blocks $$q = q'$$. Let $$I_i \coloneqq x_i||t_i$$ denote the $$i$$-th input passed to $$H'$$ when computing $$H(x)$$, and let $$I_i' \coloneqq x_i'||t_i'$$ denote the $$i$$-th input passed to $$H'$$ when computing $$H(x')$$. Additionally, we will denote the output of $$H(x)$$ as $$I_{q+1} \coloneqq t_{q+1}$$, and we will denote the output of $$H(x')$$ as $$I_{q'+1}' \coloneqq t_{q'+1}'$$.

Now, $$H(x) = H(x')$$ and so $$I_{q+1} = t_{q+1} = I_{q'+1}' = t_{q'+1}'$$. This can only happen if $$I_q = I_{q'}'$$ or if $$(I_q, I_{q'}')$$ is a collision pair for $$H'$$ and the same logic propagates backwards - in general, $$H'(I_i) = H'(I_i')$$ can be true only if $$I_i = I_i'$$ or if $$(I_i, I_{i'}')$$ is a collision pair for $$H'$$. The inputs $$x, x'$$ are a collision pair for $$H$$ which means that $$x \ne x'$$ and so there _must_ be some index $$j$$ for which $$x_j \ne x_j'$$ which means for sure that $$I_j \ne I_j'$$ and so $$(I_j, I_j')$$ turn out to be a collision in $$H'$$, which is a contradiction.

</details>
